#!/usr/bin/env node

/**
 * Module dependencies.
 */
var app   = require('../app');
var debug = require('debug')('project-shield:server');
var http  = require('http');
var firebase = require('firebase');
var linebot = require('linebot');
const line = require('@line/bot-sdk');
var apiai = require('apiai');

var config = {
  apiKey: "AIzaSyAqzIra9YkeE0HZZBSwXrjh4GemO7yVdmI",
  authDomain: "shield-88fd0.firebaseapp.com",
  databaseURL: "https://shield-88fd0.firebaseio.com",
  projectId: "shield-88fd0",
  storageBucket: "shield-88fd0.appspot.com",
  messagingSenderId: "376341346069"
};
firebase.initializeApp(config);

const usersRef = firebase.database().ref().child('chats/users');
const agentsRef = firebase.database().ref().child('chats/agents');

const auth = firebase.auth();
// console.log(auth.app);

/**
 * Get port from environment and store in Express.
 */

var port = normalizePort(process.env.PORT || '3000');
app.set('port', port);

/**
 * Create HTTP server.
 */

var server = http.createServer(app);
const io = require('socket.io').listen(server);

/**
 * Variables
 */
var users = {};
//webhook event
var message_lineTochat;
var receiverId = 'Ue369116591fbd2d13a7eb5f0ff12547b';
// LINE bot設定
var bot = linebot({
  channelId: '1516667468',
  channelSecret: 'd89c9a5ef9ae83fbdfd2fc59ab451f98',
  channelAccessToken: 'yeeDeC5dExJDeVEPPf2dMTlAoZE4izrqX6bBaldhddpG7esOFEpxm5m5dMIIB7pz0zIS49QZxJBFgAkxQZWmfy9toaiTR+B/q1pz7F5xkf+dljkSJV1krOOtrT93BSSYydIZLnt0zxX8JCqWF4uE4wdB04t89/1O/w1cDnyilFU='
});
const linebotParser = bot.parser();
const client = new line.Client({
  channelAccessToken: 'yeeDeC5dExJDeVEPPf2dMTlAoZE4izrqX6bBaldhddpG7esOFEpxm5m5dMIIB7pz0zIS49QZxJBFgAkxQZWmfy9toaiTR+B/q1pz7F5xkf+dljkSJV1krOOtrT93BSSYydIZLnt0zxX8JCqWF4uE4wdB04t89/1O/w1cDnyilFU='
});

// api ai setting
var appApiai = apiai("6fd13e1dd00b4d93881e1e75cdf02bd4");

/**
 * Listen on provided port, on all network interfaces.
 */

server.listen(port);
server.on('error', onError);
server.on('listening', onListening);

// 接收訊息
// LINE bot implement
bot.on('message', event => {
  console.log(event);
  let d = Date.now();
  let date = new Date(d);
  let imgBuf;
  message_lineTochat = event.message.text;
  receiverId = event.source.userId;

  if(event.message.type === 'sticker') {
    console.log(event);
    console.log(event.message.content);
    io.sockets.emit('new message', {msg: 'Sticker Sent. Please check your phone.', name: 'Visitor'});
  } else if(event.message.type === 'image'){
    console.log(event);
    const stream = client.getMessageContent(event.message.id);
    stream.on('data', (chunk) => {
      console.log(chunk);
      io.sockets.emit('img-chunk', chunk);
    });
    stream.on('error', (err) => {
      console.log(err);
    });

    console.log('image goes through');
  } else if(event.message.type === 'video'){
    console.log(event);
  } else if(event.message.type === 'audio'){
    console.log(event);
  } else if(event.message.type === 'file'){
    console.log(event);
  } else if(event.message.type === 'location'){
    console.log(event);
  } else if(event.message.type === 'text' && (event.message.text.indexOf('.com') !== -1 || event.message.text.indexOf('.edu') !== -1 || event.message.text.indexOf('.net') !== -1 || event.message.text.indexOf('.io') !== -1)) {
    io.sockets.emit('new message', {msg: '<a href="https://' + message_lineTochat + '/" target="_blank">' + message_lineTochat + '</a>', name: 'Visitor'});
    usersRef.push({
      message: message_lineTochat,
      user: receiverId,
      messageTime: date.toString()
    });
  } else {
    io.sockets.emit('new message', {msg: message_lineTochat, name: 'Visitor'});
    usersRef.push({
      message: message_lineTochat,
      user: receiverId,
      messageTime: date.toString()
    });
  }

  var request = appApiai.textRequest(message_lineTochat, {
    sessionId: '46110120-6a78-4a0e-a5f0-a8596b53d37e'
  });
  request.on('response', function(response) {
    console.log(response);
    let res_msg = response.result.fulfillment.speech
    if(response.result.action !== 'input.unknown') {
      io.sockets.emit('new message', {msg: res_msg, name: 'BOT'});
      event.reply({ type: 'text', text: 'BOT：' + res_msg });
    }
  });
  request.on('error', function(error) {
    console.log(error);
  });
  request.end();

});
app.post('/webhook/', linebotParser);

/**
 * Socket.io
 */
//連接
io.sockets.on('connection', (socket) => {

  // 新使用者
  socket.on('new user', (data, callback) => {
    // if(nicknames.indexOf(data) != -1){
    if(data in users){
      callback(false);
    } else {
      callback(true);
      socket.nickname = data;
      users[socket.nickname] = socket;
      // nicknames.push(socket.nickname);
      updateNicknames();
    }
  });

  function updateNicknames(){
    io.sockets.emit('usernames', Object.keys(users));
  }

  // 後台傳送訊息
  socket.on('send message', (data, callback) => {
    var msg = data.trim();
    var message;

    if(msg.includes('/sticker')){
      message = {
        type: "sticker",
        packageId: "1",
        stickerId: "10"
      };
    } else {
      message = {
        type: "text",
        text: msg
      };
    }

    let d = Date.now();
    let date = new Date(d);

    // 訊息傳到後台介面上
    if(msg.indexOf('.com') !== -1 || msg.indexOf('.edu') !== -1 || msg.indexOf('.net') !== -1 || msg.indexOf('.io') !== -1){
      io.sockets.emit('new message', {msg: '<a href="https://' + message + '/" target="_blank">' + message + '</a>', name: socket.nickname});
    } else if(msg.includes('/sticker')) {
      io.sockets.emit('new message', {msg: 'Send sticker to user', name: socket.nickname});
    } else {
      io.sockets.emit('new message', {msg: msg, name: socket.nickname});
    }

    // 訊息傳到LINE
    if(receiverId !== undefined) {
      bot.push(receiverId, message);
    }

    // 訊息儲存到firebase資料庫
    agentsRef.push({
      message: msg,
      agent: socket.nickname,
      messageTime: date.toString()
    });
  });

  socket.on('disconnect', (data) => {
    if(!socket.nickname) return;
    delete users[socket.nickname];
    // nicknames.splice(nicknames.indexOf(socket.nickname), 1);
    updateNicknames();
  });
});

// catch 404 and forward to error handler
app.use(function(req, res, next) {
  var err = new Error('Not Found');
  err.status = 404;
  next(err);
});

// error handler
app.use(function(err, req, res, next) {
  // set locals, only providing error in development
  res.locals.message = err.message;
  res.locals.error = req.app.get('env') === 'development' ? err : {};

  // render the error page
  res.status(err.status || 500);
  res.render('error');
});

/**
 * Normalize a port into a number, string, or false.
 */

function normalizePort(val) {
  var port = parseInt(val, 10);

  if (isNaN(port)) {
    // named pipe
    return val;
  }

  if (port >= 0) {
    // port number
    return port;
  }

  return false;
}

/**
 * Event listener for HTTP server "error" event.
 */

function onError(error) {
  if (error.syscall !== 'listen') {
    throw error;
  }

  var bind = typeof port === 'string'
    ? 'Pipe ' + port
    : 'Port ' + port;

  // handle specific listen errors with friendly messages
  switch (error.code) {
    case 'EACCES':
      console.error(bind + ' requires elevated privileges');
      process.exit(1);
      break;
    case 'EADDRINUSE':
      console.error(bind + ' is already in use');
      process.exit(1);
      break;
    default:
      throw error;
  }
}

/**
 * Event listener for HTTP server "listening" event.
 */

function onListening() {
  var addr = server.address();
  var bind = typeof addr === 'string'
    ? 'pipe ' + addr
    : 'port ' + addr.port;
  debug('Listening on ' + bind);
}
